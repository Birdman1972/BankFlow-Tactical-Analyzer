/**
 * WASM Platform Implementation
 *
 * Implements PlatformAPI for Web/WASM environment.
 * Uses browser File API and WASM-compiled bankflow-core.
 */

import type { PlatformAPI } from "./platform";
import type {
  FileInfo,
  AnalysisSettings,
  AnalysisResult,
  ProgressInfo,
} from "./app";
import { addLog } from "./app";

// ============================================
// WASM Module Types (from bankflow-core)
// ============================================

// WASM module types are declared in bankflow-core-wasm.d.ts
// The actual module will be generated by wasm-pack from crates/bankflow-core

// ============================================
// File State (stored in memory for web)
// ============================================

interface LoadedFile {
  bytes: Uint8Array;
  name: string;
  info: FileInfo;
}

let fileAData: LoadedFile | null = null;
let fileBData: LoadedFile | null = null;

// Store last analysis result for export
interface WasmAnalysisData {
  transactions: unknown[];
  income: unknown[];
  expense: unknown[];
  totalRecords: number;
  incomeCount: number;
  expenseCount: number;
}
let lastAnalysisData: WasmAnalysisData | null = null;

// WASM module reference (type from bankflow-core-wasm.d.ts)
let wasmModule:
  | typeof import("$lib/wasm/bankflow-core-wasm/bankflow_core.js")
  | null = null;

/**
 * Recursively convert Map objects to plain JavaScript objects
 * Required because serde_wasm_bindgen returns Maps instead of plain objects
 */
function mapToObject(value: unknown): unknown {
  if (value instanceof Map) {
    const obj: Record<string, unknown> = {};
    value.forEach((v, k) => {
      obj[k] = mapToObject(v);
    });
    return obj;
  }
  if (Array.isArray(value)) {
    return value.map(mapToObject);
  }
  return value;
}

// ============================================
// WASM Platform Implementation
// ============================================

export class WasmPlatform implements PlatformAPI {
  readonly platformName = "Web (WASM)";
  readonly supportsWhois = false; // CORS restrictions
  readonly supportsFileDialog = true; // Uses browser file input

  // ----------------------------------------
  // Initialization
  // ----------------------------------------

  async initialize(): Promise<void> {
    try {
      addLog("info", "Loading WASM module...");
      // Dynamic import of WASM module
      const wasm =
        await import("$lib/wasm/bankflow-core-wasm/bankflow_core.js");

      // In production, load WASM from public folder
      // In development, let wasm-bindgen resolve it via import.meta.url
      const isDev = import.meta.env.DEV;
      if (isDev) {
        await wasm.default();
      } else {
        // Production: explicitly provide WASM URL from public folder
        const wasmUrl = new URL(
          "/wasm/bankflow_core_bg.wasm",
          window.location.origin,
        );
        // Cast to any to handle wasm-bindgen init signature variation
        await (wasm.default as (input?: URL | string) => Promise<void>)(
          wasmUrl,
        );
      }

      wasmModule = wasm;
      addLog("success", "WASM module loaded");
    } catch (error) {
      addLog("error", `Failed to load WASM module: ${error}`);
      // Continue without WASM - will use fallback or show error on operations
      console.warn("WASM module not available, some features may be limited");
    }
  }

  // ----------------------------------------
  // File Operations
  // ----------------------------------------

  async selectAndLoadFileA(): Promise<FileInfo> {
    const file = await this.selectFile("Select Transaction File (File A)");
    const bytes = await this.readFileAsBytes(file);

    // Parse file to get metadata (using WASM or basic parsing)
    const info = await this.parseFileMetadata(bytes, file.name, "A");

    fileAData = { bytes, name: file.name, info };
    addLog(
      "success",
      `File A loaded: ${info.filename} (${info.rowCount} rows)`,
    );

    return info;
  }

  async selectAndLoadFileB(): Promise<FileInfo> {
    const file = await this.selectFile("Select IP Log File (File B)");
    const bytes = await this.readFileAsBytes(file);

    const info = await this.parseFileMetadata(bytes, file.name, "B");

    fileBData = { bytes, name: file.name, info };
    addLog(
      "success",
      `File B loaded: ${info.filename} (${info.rowCount} rows)`,
    );

    return info;
  }

  async clearAllFiles(): Promise<void> {
    fileAData = null;
    fileBData = null;
    lastAnalysisData = null;
    addLog("info", "All files cleared");
  }

  // ----------------------------------------
  // Analysis
  // ----------------------------------------

  async runAnalysis(
    settings: AnalysisSettings,
    onProgress?: (progress: ProgressInfo) => void,
  ): Promise<AnalysisResult> {
    if (!fileAData || !fileBData) {
      throw new Error("Both files must be loaded before analysis");
    }

    if (!wasmModule) {
      throw new Error("WASM module not loaded. Please refresh the page.");
    }

    addLog("info", "Starting analysis...");

    // Report progress
    onProgress?.({
      stage: "analyzing",
      progress: 0,
      message: "Processing files...",
    });

    try {
      onProgress?.({
        stage: "matching",
        progress: 50,
        message: "Matching IP addresses...",
      });

      // Call WASM analyze function with correct parameters
      // Signature: analyze(file_a_bytes, file_a_name, file_b_bytes, file_b_name, hide_sensitive, ip_cross_reference)
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const analyzeFn = wasmModule.analyze as any;
      const result = analyzeFn(
        fileAData.bytes,
        fileAData.name,
        fileBData.bytes,
        fileBData.name,
        settings.hideSensitive,
        settings.ipCrossReference,
      ) as WasmAnalysisData;

      // WASM returns a JavaScript Map, convert to plain objects recursively
      const resultMap = result as unknown as Map<string, unknown>;
      const analysisData: WasmAnalysisData = {
        transactions: mapToObject(
          resultMap.get("transactions") || [],
        ) as unknown[],
        income: mapToObject(resultMap.get("income") || []) as unknown[],
        expense: mapToObject(resultMap.get("expense") || []) as unknown[],
        totalRecords: (resultMap.get("totalRecords") || 0) as number,
        incomeCount: (resultMap.get("incomeCount") || 0) as number,
        expenseCount: (resultMap.get("expenseCount") || 0) as number,
      };

      // Store for export
      lastAnalysisData = analysisData;

      onProgress?.({
        stage: "complete",
        progress: 100,
        message: "Analysis complete!",
      });

      // Compute matched/multi-IP counts from transactions
      const transactions = analysisData.transactions as Array<{
        matched_ips?: string[];
      }>;
      const matchedCount = transactions.filter(
        (t) => t.matched_ips && t.matched_ips.length > 0,
      ).length;
      const multiIpCount = transactions.filter(
        (t) => t.matched_ips && t.matched_ips.length > 1,
      ).length;
      const totalRecords = analysisData.totalRecords;

      const analysisResult: AnalysisResult = {
        totalRecords,
        matchedCount,
        multiIpCount,
        whoisQueried: 0, // Not supported in web
        settings: {
          hideSensitive: settings.hideSensitive,
          splitIncomeExpense: settings.splitIncomeExpense,
          ipCrossReference: settings.ipCrossReference,
          whoisLookup: false,
        },
      };

      addLog(
        "success",
        `Analysis complete: ${matchedCount}/${totalRecords} records matched`,
      );

      if (multiIpCount > 0) {
        addLog(
          "warning",
          `${multiIpCount} transactions have multiple IP matches`,
        );
      }

      return analysisResult;
    } catch (error) {
      addLog("error", `Analysis failed: ${error}`);
      throw error;
    }
  }

  // ----------------------------------------
  // Export
  // ----------------------------------------

  async exportReport(): Promise<string> {
    if (!lastAnalysisData) {
      throw new Error("Please run analysis first before exporting");
    }

    if (!wasmModule) {
      throw new Error("WASM module not loaded");
    }

    addLog("info", "Generating Excel report...");

    try {
      // export_excel expects JSON string with { transactions, income, expense }
      const exportData = JSON.stringify({
        transactions: lastAnalysisData.transactions,
        income: lastAnalysisData.income,
        expense: lastAnalysisData.expense,
      });

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const exportFn = wasmModule.export_excel as any;
      const excelBytes = exportFn(exportData) as Uint8Array;

      // Trigger download
      const filename = `bankflow_report_${new Date().toISOString().split("T")[0]}.xlsx`;
      this.downloadFile(
        excelBytes,
        filename,
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      );

      addLog("success", `Report exported: ${filename}`);
      return `Successfully exported report: ${filename}`;
    } catch (error) {
      addLog("error", `Export failed: ${error}`);
      throw error;
    }
  }

  // ----------------------------------------
  // Whois (Not supported in web due to CORS)
  // ----------------------------------------

  // queryWhois is intentionally not implemented
  // The interface marks it as optional

  // ----------------------------------------
  // Helper Methods
  // ----------------------------------------

  private selectFile(_title: string): Promise<File> {
    return new Promise((resolve, reject) => {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = ".xlsx,.xls";

      input.onchange = () => {
        const file = input.files?.[0];
        if (file) {
          resolve(file);
        } else {
          reject(new Error("No file selected"));
        }
      };

      input.oncancel = () => {
        reject(new Error("File selection cancelled"));
      };

      // Trigger file picker
      input.click();
    });
  }

  private async readFileAsBytes(file: File): Promise<Uint8Array> {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        if (reader.result instanceof ArrayBuffer) {
          resolve(new Uint8Array(reader.result));
        } else {
          reject(new Error("Failed to read file as bytes"));
        }
      };
      reader.onerror = () => reject(reader.error);
      reader.readAsArrayBuffer(file);
    });
  }

  private async parseFileMetadata(
    bytes: Uint8Array,
    filename: string,
    fileType: "A" | "B",
  ): Promise<FileInfo> {
    // For now, return basic metadata
    // In a full implementation, WASM would parse the Excel file
    // and return actual row/column counts

    // Estimate rows from file size (rough approximation)
    const estimatedRows = Math.floor(bytes.length / 100);

    return {
      path: filename, // No real path in browser
      filename,
      rowCount: estimatedRows, // Will be updated after actual parsing
      columnCount: fileType === "A" ? 10 : 3, // Estimated
      fileType: filename.split(".").pop() ?? "xlsx",
      isValid: true,
    };
  }

  private downloadFile(
    bytes: Uint8Array,
    filename: string,
    mimeType: string,
  ): void {
    // Create a copy to ensure proper ArrayBuffer type
    const blob = new Blob([bytes.slice()], { type: mimeType });
    const url = URL.createObjectURL(blob);

    const link = document.createElement("a");
    link.href = url;
    link.download = filename;
    link.click();

    // Cleanup
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }
}
