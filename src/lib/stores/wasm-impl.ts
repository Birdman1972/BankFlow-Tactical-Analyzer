/**
 * WASM Platform Implementation
 *
 * Implements PlatformAPI for Web/WASM environment.
 * Uses browser File API and WASM-compiled bankflow-core.
 */

import type { PlatformAPI } from './platform';
import type { FileInfo, AnalysisSettings, AnalysisResult, ProgressInfo } from './app';
import { addLog } from './app';

// ============================================
// WASM Module Types (from bankflow-core)
// ============================================

// WASM module types are declared in bankflow-core-wasm.d.ts
// The actual module will be generated by wasm-pack from crates/bankflow-core

// ============================================
// File State (stored in memory for web)
// ============================================

interface LoadedFile {
  bytes: Uint8Array;
  name: string;
  info: FileInfo;
}

let fileAData: LoadedFile | null = null;
let fileBData: LoadedFile | null = null;

// WASM module reference (type from bankflow-core-wasm.d.ts)
let wasmModule: typeof import('$lib/wasm/bankflow-core-wasm/bankflow_core.js') | null = null;

// ============================================
// WASM Platform Implementation
// ============================================

export class WasmPlatform implements PlatformAPI {
  readonly platformName = 'Web (WASM)';
  readonly supportsWhois = false; // CORS restrictions
  readonly supportsFileDialog = true; // Uses browser file input

  // ----------------------------------------
  // Initialization
  // ----------------------------------------

  async initialize(): Promise<void> {
    try {
      addLog('info', 'Loading WASM module...');
      // Dynamic import of WASM module
      const wasm = await import('$lib/wasm/bankflow-core-wasm/bankflow_core.js');

      // In production, load WASM from public folder
      // In development, let wasm-bindgen resolve it via import.meta.url
      const isDev = import.meta.env.DEV;
      if (isDev) {
        await wasm.default();
      } else {
        // Production: explicitly provide WASM URL from public folder
        const wasmUrl = new URL('/wasm/bankflow_core_bg.wasm', window.location.origin);
        await wasm.default(wasmUrl);
      }

      wasmModule = wasm;
      addLog('success', 'WASM module loaded');
    } catch (error) {
      addLog('error', `Failed to load WASM module: ${error}`);
      // Continue without WASM - will use fallback or show error on operations
      console.warn('WASM module not available, some features may be limited');
    }
  }

  // ----------------------------------------
  // File Operations
  // ----------------------------------------

  async selectAndLoadFileA(): Promise<FileInfo> {
    const file = await this.selectFile('Select Transaction File (File A)');
    const bytes = await this.readFileAsBytes(file);

    // Parse file to get metadata (using WASM or basic parsing)
    const info = await this.parseFileMetadata(bytes, file.name, 'A');

    fileAData = { bytes, name: file.name, info };
    addLog('success', `File A loaded: ${info.filename} (${info.rowCount} rows)`);

    return info;
  }

  async selectAndLoadFileB(): Promise<FileInfo> {
    const file = await this.selectFile('Select IP Log File (File B)');
    const bytes = await this.readFileAsBytes(file);

    const info = await this.parseFileMetadata(bytes, file.name, 'B');

    fileBData = { bytes, name: file.name, info };
    addLog('success', `File B loaded: ${info.filename} (${info.rowCount} rows)`);

    return info;
  }

  async clearAllFiles(): Promise<void> {
    fileAData = null;
    fileBData = null;
    addLog('info', 'All files cleared');
  }

  // ----------------------------------------
  // Analysis
  // ----------------------------------------

  async runAnalysis(
    settings: AnalysisSettings,
    onProgress?: (progress: ProgressInfo) => void
  ): Promise<AnalysisResult> {
    if (!fileAData || !fileBData) {
      throw new Error('Both files must be loaded before analysis');
    }

    if (!wasmModule) {
      throw new Error('WASM module not loaded. Please refresh the page.');
    }

    addLog('info', 'Starting analysis...');

    // Report progress
    onProgress?.({ stage: 'analyzing', progress: 0, message: 'Processing files...' });

    try {
      // Call WASM analyze function
      const settingsJson = JSON.stringify({
        hide_sensitive: settings.hideSensitive,
        split_income_expense: settings.splitIncomeExpense,
        ip_cross_reference: settings.ipCrossReference,
        whois_lookup: false, // Whois not supported in web
      });

      onProgress?.({ stage: 'matching', progress: 50, message: 'Matching IP addresses...' });

      const resultJson = wasmModule.analyze(
        fileAData.bytes,
        fileAData.name,
        fileBData.bytes,
        fileBData.name,
        settingsJson
      );

      const result = JSON.parse(resultJson);

      onProgress?.({ stage: 'complete', progress: 100, message: 'Analysis complete!' });

      const analysisResult: AnalysisResult = {
        totalRecords: result.total_records,
        matchedCount: result.matched_count,
        multiIpCount: result.multi_ip_count,
        whoisQueried: 0, // Not supported in web
        settings: {
          hideSensitive: settings.hideSensitive,
          splitIncomeExpense: settings.splitIncomeExpense,
          ipCrossReference: settings.ipCrossReference,
          whoisLookup: false,
        },
      };

      addLog('success', `Analysis complete: ${analysisResult.matchedCount}/${analysisResult.totalRecords} records matched`);

      if (analysisResult.multiIpCount > 0) {
        addLog('warning', `${analysisResult.multiIpCount} transactions have multiple IP matches`);
      }

      return analysisResult;
    } catch (error) {
      addLog('error', `Analysis failed: ${error}`);
      throw error;
    }
  }

  // ----------------------------------------
  // Export
  // ----------------------------------------

  async exportReport(): Promise<string> {
    if (!fileAData || !fileBData) {
      throw new Error('Both files must be loaded before export');
    }

    if (!wasmModule) {
      throw new Error('WASM module not loaded');
    }

    addLog('info', 'Generating Excel report...');

    try {
      const settingsJson = JSON.stringify({
        hide_sensitive: false,
        split_income_expense: true,
        ip_cross_reference: true,
        whois_lookup: false,
      });

      const excelBytes = wasmModule.export_excel(
        fileAData.bytes,
        fileAData.name,
        fileBData.bytes,
        fileBData.name,
        settingsJson
      );

      // Trigger download
      const filename = `bankflow_report_${new Date().toISOString().split('T')[0]}.xlsx`;
      this.downloadFile(excelBytes, filename, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');

      addLog('success', `Report exported: ${filename}`);
      return `Successfully exported report: ${filename}`;
    } catch (error) {
      addLog('error', `Export failed: ${error}`);
      throw error;
    }
  }

  // ----------------------------------------
  // Whois (Not supported in web due to CORS)
  // ----------------------------------------

  // queryWhois is intentionally not implemented
  // The interface marks it as optional

  // ----------------------------------------
  // Helper Methods
  // ----------------------------------------

  private selectFile(_title: string): Promise<File> {
    return new Promise((resolve, reject) => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.xlsx,.xls';

      input.onchange = () => {
        const file = input.files?.[0];
        if (file) {
          resolve(file);
        } else {
          reject(new Error('No file selected'));
        }
      };

      input.oncancel = () => {
        reject(new Error('File selection cancelled'));
      };

      // Trigger file picker
      input.click();
    });
  }

  private async readFileAsBytes(file: File): Promise<Uint8Array> {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        if (reader.result instanceof ArrayBuffer) {
          resolve(new Uint8Array(reader.result));
        } else {
          reject(new Error('Failed to read file as bytes'));
        }
      };
      reader.onerror = () => reject(reader.error);
      reader.readAsArrayBuffer(file);
    });
  }

  private async parseFileMetadata(
    bytes: Uint8Array,
    filename: string,
    fileType: 'A' | 'B'
  ): Promise<FileInfo> {
    // For now, return basic metadata
    // In a full implementation, WASM would parse the Excel file
    // and return actual row/column counts

    // Estimate rows from file size (rough approximation)
    const estimatedRows = Math.floor(bytes.length / 100);

    return {
      path: filename, // No real path in browser
      filename,
      rowCount: estimatedRows, // Will be updated after actual parsing
      columnCount: fileType === 'A' ? 10 : 3, // Estimated
      fileType: filename.split('.').pop() ?? 'xlsx',
    };
  }

  private downloadFile(bytes: Uint8Array, filename: string, mimeType: string): void {
    // Create a copy to ensure proper ArrayBuffer type
    const blob = new Blob([bytes.slice()], { type: mimeType });
    const url = URL.createObjectURL(blob);

    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    link.click();

    // Cleanup
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }
}
